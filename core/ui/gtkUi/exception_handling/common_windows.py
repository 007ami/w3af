'''
common_windows_report.py

Copyright 2012 Andres Riancho

This file is part of w3af, w3af.sourceforge.net .

w3af is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

w3af is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with w3af; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

'''
import sys
sys.path.append('/home/pablo/workspace/error_handling/')
import gtk
import cgi
import Queue
import threading
import gobject
import webbrowser

from core.ui.gtkUi.helpers import endThreads
from core.ui.gtkUi.entries import EmailEntry
from core.ui.gtkUi.helpers import Throbber



class simple_base_window(gtk.Window):

    def __init__(self, _type=None):
        '''
        One simple class to create other windows.
        '''
        super(simple_base_window,self).__init__(_type=gtk.WINDOW_TOPLEVEL)
        self.connect("delete-event", gtk.main_quit)
        
    def _handle_cancel(self, widg):
        endThreads()
        self.destroy()


class bug_report_worker(threading.Thread):
    '''
    The simplest threading object possible to report bugs to the network without
    blocking the UI.
    '''
    FINISHED = -1
    
    def __init__(self, bug_report_function, bugs_to_report):
        threading.Thread.__init__(self)
        self.bug_report_function = bug_report_function
        self.bugs_to_report = bugs_to_report
        self.output = Queue.Queue()

    def run(self):
        '''
        The thread's main method, where all the magic happens.
        '''
        for bug in self.bugs_to_report:
            result = self.bug_report_function(bug)
            self.output.put(result)
        
        self.output.put(self.FINISHED)


class report_bug_show_result(simple_base_window):
    '''
    A class that shows the result of one or more bug reports to the user. The
    window shows a "Thanks" message and links to the bugs that were generated.
    
    Unlike previous versions, this window actually sends the bugs to the network
    since we want to show the ticket IDs "in real time" to the user instead of
    reporting them all and then showing a long list of items.
    '''
    
    def __init__(self, bug_report_function, bugs_to_report):
        '''
        @param bug_report_function: The function that's used to report bugs.
                                    Should only take ONE parameter: a bug.
                                    
        @param bugs_to_report: An iterable with the bugs to report. These are
                               going to be the parameters for the bug_report_function.
        '''
        super(report_bug_show_result,self).__init__(type=gtk.WINDOW_TOPLEVEL)
        
        self.set_modal(True)
        self.set_title('Bug report results')
        self.set_icon_from_file('core/ui/gtkUi/data/w3af_icon.png')
        self.vbox = gtk.VBox()
        
        self.label = gtk.Label()
        self.label.set_line_wrap(True)
        self.label.set_selectable(True)
        
        #
        #    Main text
        #
        text = 'Thank you for reporting your bugs, it helps us improve our'
        text += ' scanning engine. If you want to get involved with the project'
        text += ' please send an email to our <a href="mailto:%s">mailing list</a>.'
        text = text % ('w3af-develop@lists.sourceforge.net')
        self.label.set_markup( text )
        
        self.vbox.pack_start(self.label, True, False)
        
        self.worker = bug_report_worker(bug_report_function, bugs_to_report)
        self.worker.start()        
        gobject.timeout_add(500, self.add_result_from_worker)
        
        #
        #    Throbber, only show while still running.
        #
        self.throbber = Throbber()
        self.throbber.running(True)
        self.vbox.pack_start(self.throbber)
        
        #
        #    Check, hidden at the beginning 
        #    http://www.pygtk.org/docs/pygtk/gtk-stock-items.html
        #
        self.done_icon = gtk.Image()
        self.done_icon.set_from_stock(gtk.STOCK_YES)
        
        # Close button
        self.butt_close = gtk.Button(stock=gtk.STOCK_CLOSE)
        self.butt_close.connect("clicked", self._handle_cancel )
        self.vbox.pack_start(self.butt_close, True, False)
        
        self.add(self.vbox)
        self.show_all()
        self.done_icon.hide()
        
        # This is a quick fix to get around the problem generated by "set_selectable"
        # that selects the text by default
        self.label.select_region(0, 0)
        
      
    def add_result_from_worker(self):
        '''
        Adds the results from the worker to the text that's shown in the window
        '''
        # The links to the reported tickets
        try:
            bug_report_result = self.worker.output.get(block=False)
        except Queue.Empty:
            # The worker is reporting stuff to the network and doesn't
            # have any results at this moment. Call me in some seconds.
            return True
        
        if bug_report_result == self.worker.FINISHED:
            self.throbber.running(False)
            self.throbber.hide()
            self.done_icon.show()
            # don't call me anymore !
            return False
        else:
            # Add the data to the label and ask to be called again
            ticket_id, ticket_url = bug_report_result
            self.add_link(ticket_id, ticket_url)
            return True

    def add_link(self, ticket_id, ticket_url):
        link = gtk.EventBox()
        link.set_events(gtk.gdk.BUTTON_PRESS_MASK)
        
        link_label_text = '\n<u><span foreground="#0000AA">'
        link_label_text += cgi.escape(ticket_id)+'</span></u>\n'
        linkLabel = gtk.Label( link_label_text )
        linkLabel.set_line_wrap(True)
        linkLabel.set_use_markup( True )
        link.add( linkLabel )
        link.connect( 'button_press_event', self.on_link_clicked, ticket_id, ticket_url )
        link.show_all()
        self.vbox.pack_start(link)
                
    def on_link_clicked(self, widg, evt, ticket_id, ticket_url):
        '''
        Open a web browser with the corresponding URL, sometimes it's the
        URL for the newly reported bug, sometimes it's the URL for a manual bug report.
        '''
        webbrowser.open(ticket_url)


class dlg_ask_credentials(gtk.MessageDialog):
    '''
    A dialog that allows any exception handler to ask the user for his credentials
    before sending any bug report information to the network. The supported types
    of credentials are:
    
        * Anonymous
        * Email
        * Sourceforge user (soon to be deprecated, nobody uses it).
    
    '''

    METHOD_ANON = 1
    METHOD_EMAIL = 2
    METHOD_SF = 3

    def __init__(self, invalid_login=False):
        '''
        @return: A tuple with the following information:
                    (method, params)
                
                Where method is one of METHOD_ANON, METHOD_EMAIL, METHOD_SF and,
                params is the email or the sourceforge username and password,
                in the anon case, the params are empty.
        '''
        gtk.MessageDialog.__init__(self,
                                   None,
                                   gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                                   gtk.MESSAGE_QUESTION,
                                   gtk.BUTTONS_OK_CANCEL,
                                   None)
        self.set_icon_from_file('core/ui/gtkUi/data/w3af_icon.png')
        
        self._invalid_login = invalid_login
    
    def run(self):
        '''
        Setup the dialog and return the results to the invoker.
        '''
        
        msg = '<b>Step 1 of 2</b>\n\n\n'
        if self._invalid_login:
            msg += '<b><i>Your credentials are invalid, please try again.</i></b>\n\n'
        
        msg += 'Choose how you\'ll report the bug(s):'
        self.set_markup( msg )
    
        #
        #    Anon
        #
        anon_button = gtk.RadioButton(None, "Anonymously")
        anon_button.set_active(True)
        self.vbox.pack_start(anon_button, True, True, 0)
    
        separator = gtk.HSeparator()
        self.vbox.pack_start(separator, True, True, 0)
        
        #
        #    Email
        #
        email_button = gtk.RadioButton(anon_button, "Use email address")
        self.vbox.pack_start(email_button, True, True, 0)
        
        # Create the text input field
        self.email_entry = EmailEntry(self._email_entry_changed)
        self.email_entry.connect("activate", lambda x: self.response(gtk.RESPONSE_OK))  
        
        # Create a horizontal box to pack the entry and a label
        email_hbox = gtk.HBox()
        email_hbox.pack_start(gtk.Label("Email address:"), False, 5, 5)
        email_hbox.pack_end(self.email_entry)
        email_hbox.set_sensitive(False)
        self.vbox.pack_start(email_hbox, True, True, 0)
        
        separator = gtk.HSeparator()
        self.vbox.pack_start(separator, True, True, 0)
    
        #
        #    Sourceforge credentials
        #
        sf_button = gtk.RadioButton(email_button, "Sourceforge credentials:")
        self.vbox.pack_start(sf_button, True, True, 0)
        
        sf_vbox = gtk.VBox()
        
        # Create the text input field
        user_entry = gtk.Entry()
        user_entry.connect("activate", lambda x: self.response(gtk.RESPONSE_OK))  
    
        user_hbox = gtk.HBox()
        user_hbox.pack_start(gtk.Label("Username:  "), False, 5, 5)
        user_hbox.pack_end(user_entry)
        sf_vbox.pack_start(user_hbox, True, True, 0)
        
        # Create the password entry
        passwd_entry = gtk.Entry()
        passwd_entry.set_visibility(False)
        passwd_entry.connect("activate", lambda x: self.response(gtk.RESPONSE_OK))  
    
        passwd_hbox = gtk.HBox()
        passwd_hbox.pack_start(gtk.Label("Password:  "), False, 5, 5)
        passwd_hbox.pack_end(passwd_entry)
        sf_vbox.pack_start(passwd_hbox, True, True, 0)
        
        # Some secondary text
        warning_label = gtk.Label()
        warning = "\nYour credentials won't be stored in your computer,\n"
        warning += "  and will only be sent over HTTPS connections."
        warning_label.set_text(warning)
        sf_vbox.pack_start(warning_label, True, True, 0)
        sf_vbox.set_sensitive(False)
        self.vbox.pack_start(sf_vbox, True, True, 0)
        
        separator = gtk.HSeparator()
        self.vbox.pack_start(separator, True, True, 0)
    
        # Handling of sensitiviness between the radio contents
        anon_button.connect("toggled", self._radio_callback_anon, [], [email_hbox,sf_vbox])        
        email_button.connect("toggled", self._radio_callback_email, [email_hbox,], [sf_vbox,])
        sf_button.connect("toggled", self._radio_callback_sf, [sf_vbox,], [email_hbox,])
                
        # Go go go!        
        self.show_all()
        super(dlg_ask_credentials, self).run()
        
        #
        # Get the results, generate the result tuple and return
        #
        active_label = [r.get_label() for r in anon_button.get_group() if r.get_active()]
        active_label = active_label[0].lower()
        
        if 'email' in active_label:
            method = self.METHOD_EMAIL
            email = self.email_entry.get_text()
            params = (email,)
        elif 'sourceforge' in active_label:
            method = self.METHOD_SF
            user = user_entry.get_text()
            passwd = passwd_entry.get_text()
            params = (user, passwd)
        else:
            method = self.METHOD_ANON
            params = ()
        
        # I'm done!
        self.destroy()

        return (method, params)

    def _email_entry_changed(self, x, y):
        '''
        Disable the OK button if the email is invalid
        '''
        ok_button = self.get_widget_for_response(gtk.RESPONSE_OK)
        
        if self.email_entry.isValid():
            # Activate OK button
            ok_button.set_sensitive(True)
        else:
            # Disable OK button
            ok_button.set_sensitive(False)

    def _radio_callback_anon(self, event, enable, disable):
        self._radio_callback(event, enable, disable)
        # re-enable the button in case it was disabled by an invalid email address entry
        ok_button = self.get_widget_for_response(gtk.RESPONSE_OK)
        ok_button.set_sensitive(True)

    def _radio_callback_email(self, event, enable, disable):
        self._radio_callback(event, enable, disable)
        self._email_entry_changed(True,True)

    def _radio_callback_sf(self, event, enable, disable):
        self._radio_callback(event, enable, disable)
        # re-enable the button in case it was disabled by an invalid email address entry
        ok_button = self.get_widget_for_response(gtk.RESPONSE_OK)
        ok_button.set_sensitive(True)

    def _radio_callback(self, event, enable, disable):
        '''
        Handle the clicks on the different radio buttons.
        '''
        for section in enable:
            section.set_sensitive(True)

        for section in disable:
            section.set_sensitive(False)


if __name__ == '__main__':
    dlg = dlg_ask_credentials()
    dlg.run()