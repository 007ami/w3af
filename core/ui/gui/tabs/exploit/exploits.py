'''
exploits.py

Copyright 2007 Andres Riancho

This file is part of w3af, http://w3af.org/ .

w3af is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

w3af is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with w3af; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
'''
import gtk
import gobject

import core.data.kb.knowledge_base as kb

from core.ui.gui import helpers
from core.ui.gui.pluginEditor import pluginEditor
from core.ui.gui.tabs.exploit.utils import get_exploitable_vulns
from core.ui.gui.tabs.exploit.exploit_all import effectively_exploit_all
from core.ui.gui.tabs.exploit.utils import TextDialogConsumer
from core.data.kb.info import Info
from core.controllers.exceptions import w3afException


class ExploitTree(gtk.TreeView):
    '''A list showing all the plugins of "attack" type.

    :param w3af: The main core class.

    :author: Facundo Batista <facundobatista =at= taniquetil.com.ar>
    '''
    def __init__(self, w3af, config_panel):
        self.w3af = w3af
        self.config_panel = config_panel

        # create the ListStore, with the plugin name twice (the first could
        # go bold, the second is the original name always)
        self.liststore = gtk.ListStore(str, str)

        # just build the tree with the plugin names
        for plugin in sorted(w3af.plugins.get_plugin_list("attack")):
            self.liststore.append([plugin, plugin])

        # we will not ask for the plugin instances until needed, we'll
        # keep them here:
        self.plugin_instances = {}

        # create the TreeView using liststore
        super(ExploitTree, self).__init__(self.liststore)

        # signals
        self.connect('button-release-event', self.popup_menu)
        self.connect('cursor-changed', self._changedSelection)

        # create a TreeViewColumn for the text
        tvcolumn = gtk.TreeViewColumn(_('Exploits'))
        cell = gtk.CellRendererText()
        tvcolumn.pack_start(cell, True)
        tvcolumn.add_attribute(cell, 'markup', 0)
        self.append_column(tvcolumn)

        # drag and drop setup, this is the SOURCE
        target = [("explot-activ", 0, 1)]
        self.enable_model_drag_source(
            gtk.gdk.BUTTON1_MASK, target, gtk.gdk.ACTION_COPY)

        #self.set_enable_tree_lines(True)
        self.show()

    def set_filter(self, vuln):
        new_liststore = gtk.ListStore(str, str)
        for pname in sorted(self.w3af.plugins.get_plugin_list("attack")):
            exploit = self.w3af.plugins.get_plugin_inst("attack", pname)
            thisvulns = get_exploitable_vulns(exploit)
            markedname = ("<b>%s</b>" % pname) if vuln in thisvulns else pname
            new_liststore.append([markedname, pname])
        self.set_model(new_liststore)
        self.liststore = new_liststore

    def _changedSelection(self, *w):
        '''Changed which exploit is selected.'''
        exploit = self.get_selected_exploit()
        self.vulnerabs.set_filter(exploit)
        
        longdesc = exploit.get_long_desc()
        longdesc = helpers.clean_description(longdesc)
        self.config_panel.config(self, exploit, longdesc)

        # un-bold the rest
        for row in self.liststore:
            if row[1] != exploit.pname:
                row[0] = row[1]

    def config_changed(self, initial):
        '''
        Called when a configuration parameter in an exploit plugin changes.
        '''
        pass

    def get_selected_exploit(self):
        '''Returns the selected exploit.

        :return: The selected exploit.
        '''
        (path, column) = self.get_cursor()
        if path is None:
            return None

        # Get the information about the click
        plugin = self.get_plugin_inst(path)
        return plugin

    def popup_menu(self, tv, event):
        '''Shows a menu when you right click on a plugin.

        :param tv: the treeview.
        :param event: The GTK event
        '''
        if event.button != 3:
            return

        (path, column) = tv.get_cursor()
        # Is it over a plugin name ?
        if path is not None and len(path) == 1:
            # Get the information about the click
            plugin = self.get_plugin_inst(path)
            pname = self.liststore[path][1]

            # Ok, now I show the popup menu !
            # Create the popup menu
            gm = gtk.Menu()

            # And the items
            e = gtk.MenuItem(_("Edit plugin..."))
            e.connect('activate', self._handleEditPluginEvent, pname, path)
            gm.append(e)
            e = gtk.MenuItem(_("Exploit ALL vulns"))
            e.connect('activate', self._exploit_all, pname, False)
            gm.append(e)
            e = gtk.MenuItem(_("Exploit all until first successful"))
            e.connect('activate', self._exploit_all, pname, True)
            gm.append(e)

            gm.show_all()
            gm.popup(None, None, None, event.button, event.time)

    def _handleEditPluginEvent(self, widget, plugin_name, path):
        '''
        I get here when the user right clicks on a plugin name, then he clicks on "Edit..."
        This method calls the plugin editor with the corresponding parameters.
        '''
        def f(t, n):
            self._finishedEditingPlugin(path, plugin_name)
        pluginEditor("attack", plugin_name, f)

    def _finishedEditingPlugin(self, path, plugin_name):
        '''
        This is a callback that is called when the plugin editor finishes.
        '''
        del self.plugin_instances[path]
        self.w3af.plugins.reload_modified_plugin('attack', plugin_name)

    def _exploit_all(self, widget, pname, stoponfirst):
        '''Exploit all the vulns.'''
        effectively_exploit_all(self.w3af, [pname], stoponfirst)

    def get_plugin_inst(self, path):
        '''Caches the plugin instance.

        :param path: where the user is in the plugin list
        :return The plugin
        '''
        try:
            return self.plugin_instances[path]
        except KeyError:
            pass

        # path can be a tuple of one or two values here
        pname = self.liststore[path][1]
        plugin = self.w3af.plugins.get_plugin_inst("attack", pname)
        plugin.pname = pname
        plugin.ptype = "attack"
        self.plugin_instances[path] = plugin
        return plugin



        # initial filters
        self.applicable = []

        # drag and drop setup, this is the DESTINATION
        target = [("explot-activ", 0, 1)]
        self.enable_model_drag_dest(target, gtk.gdk.ACTION_COPY)
        self.connect("drag-data-received", self._dragDropped)

        self.connect('cursor-changed', self._changedSelection)

        # get the knowledge base and go live
        kb.kb.add_observer(None, None, self._receive_kb_items)

        self.show()

    def _changedSelection(self, *w):
        '''Changed which exploit is selected.'''
        (path, column) = self.get_cursor()
        vuln = self.get_instance(path)
        self.exploitlist.set_filter(vuln)

        # un-bold the rest
        selected = vuln.get_name()
        for row in self.liststore:
            if row[1] != selected:
                row[0] = row[1]

    def set_filter(self, exploit):
        '''Sets a new filter and update the list.

        :param active: which types should be shown.
        '''
        vulns = get_exploitable_vulns(exploit)
        if vulns is None:
            self.applicable = []
        else:
            self.applicable = vulns
        
        new_liststore = gtk.ListStore(str, str, str, gtk.gdk.Pixbuf)
        new_listholder = set()
        
        self._updateList(new_liststore, new_listholder)
        self.set_model(new_liststore)
        
        self.liststore = new_liststore
        self.listholder = new_listholder

    def _getBestObjName(self, obj):
        '''
        :return: The best obj name possible
        '''

        if hasattr(obj, "get_name"):
            realname = obj.get_name()
        else:
            realname = repr(obj)
        if obj in self.applicable:
            showname = "<b>%s</b>" % realname
        else:
            showname = "%s" % realname
        return showname, realname

    def _receive_kb_items(self, location_a, location_b, info_inst):
        '''
        Gets called by the KB when one of the plugins writes something to it.
        
        We've subscribed using kb.kb.add_observer(None, None, ...) so we'll
        get all changes.
        
        :return: None, the information we'll show to the user is stored in an
                 internal variable.
        '''
        if not isinstance(info_inst, Info):
            return
        
        obj_name = info_inst.get_name()
        obj_severity = info_inst.get_severity()
        
        # Note that I can't use id(instance) here since the
        # instances that come here are created from the SQLite DB
        # and have different instances, even though they hold the
        # same information.
        idinstance = info_inst.get_uniq_id()
        
        gobject.idle_add(self.add_item_to_lstore, obj_name, obj_severity,
                         idinstance)
        
    def add_item_to_lstore(self, obj_name, obj_severity, idinstance):
        '''Updates the GUI with the given information.
        '''
        newicon = helpers.KB_ICONS.get(("vuln", obj_severity))
        if newicon is not None:
            newicon = newicon.get_pixbuf()

        self.liststore.append((obj_name, obj_severity, idinstance, newicon))


    def get_instance(self, path):
        '''Extracts the instance from the tree.

        :param path: where the user is in the tree
        :return: The instance
        '''
        info_uniq_id = self.treestore[path][2]
        info_inst = kb.kb.get_by_uniq_id(info_uniq_id)
        return info_inst
    
    def _dragDropped(self, tv, drag_context, x, y, selection_data, info, timestamp):
        '''Something was dropped (after a drag) on us.'''
        droppoint = tv.get_dest_row_at_pos(x, y)
        if droppoint is None:
            return True

        # collect info about source and dest
        (destpath, where) = droppoint
        sourcepath = self.exploitlist.get_cursor()[0]
        sourcerow = self.exploitlist.liststore[sourcepath]

        # it should select a destination row
        if where not in (gtk.TREE_VIEW_DROP_INTO_OR_AFTER, gtk.TREE_VIEW_DROP_INTO_OR_BEFORE):
            self.w3af.mainwin.sb(
                _("You must drop into a row, not in the middle of two"))
            return

        # get real objects
        exploit = self.exploitlist.get_plugin_inst(sourcepath)
        dstvuln = self.get_instance(destpath)
        if dstvuln is None:
            self.w3af.mainwin.sb(
                _("You must select a vulnerability as destination"))
            return

        self._executeExploit(exploit, dstvuln)
        return

    def _executeExploit(self, expl, vuln):
        '''Exploits a vulnerability.

        This raises a text dialog that informs how the exploit
        is going until it finishes.

        This method is going to:
            a) Create the TextDialog
            b) spawn a thread to launch the exploit process
            c) spawn a thread to read from the output manager queue

        b and c both write messages to the TextDialog.

        :param expl: the exploit to use
        :param vuln: the vulnerability to exploit
        '''
        dlg = TextDialogConsumer("Exploit!")
        
        # Start the generator that launches the exploit
        exploit_task = self._launch_exploit(dlg, expl, vuln)
        gobject.idle_add(exploit_task.next)

        return

    def _launch_exploit(self, dlg, expl, vuln):
        '''
        Launch the exploit and write messages to the TextDialog.

        :param dlg: The TextDialog.
        '''
        # get the info, and see if we can go for it
        dlg.add_message("Checking if this attack plugin can exploit this vulnerability...\n")
        vuln_id_list = vuln.get_id()

        yield True

        try:
            canexploit = expl.can_exploit(vuln_id_list)
        except w3afException, e:
            dlg.add_message(_("\nERROR: "))
            dlg.add_message(str(e) + '\n')
            dlg.done()  # set button to sensitive
            dlg.dialog_run()  # wait for user response
            yield False

        if not canexploit:
            dlg.add_message(_("Sorry, this attack plugin can not exploit this vulnerability\n"))
            dlg.done()  # set button to sensitive
            dlg.dialog_run()  # wait for user response
            yield False

        # ok, go for it!
        dlg.add_message(_("Starting exploitation process...\n"))
        yield True

        try:
            expl.exploit(vuln_id_list)
            yield True  # print the console messages to the dialog
        except w3afException, e:
            dlg.add_message(str(e) + '\n')
        else:
            dlg.add_message(_("Done\n"))
            yield True

        dlg.done()  # set button to sensitive
        dlg.dialog_run()  # wait for user response

        yield False


