'''
vuln_list.py

Copyright 2007 Andres Riancho

This file is part of w3af, http://w3af.org/ .

w3af is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

w3af is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with w3af; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
'''
import gtk
import gobject

import core.data.kb.knowledge_base as kb

from core.ui.gui import helpers
from core.ui.gui.tabs.exploit.utils import get_exploitable_vulns
from core.ui.gui.tabs.exploit.utils import TextDialogConsumer

from core.data.kb.info import Info
from core.controllers.exceptions import w3afException


class VulnerabList(gtk.TreeView):
    '''A tree showing all the found vulnerabilities.

    :param w3af: The w3af core.
    :param exploitlist: The widget that keeps the list of exploits

    :author: Facundo Batista <facundobatista =at= taniquetil.com.ar>
    '''
    def __init__(self, w3af, exploitlist):
        self.w3af = w3af
        self.exploitlist = exploitlist

        # simple empty List Store
        # columns: the string to show, the string to order, the key
        # for the plugin instance, and the icon
        self.liststore = gtk.ListStore(str, str, str, gtk.gdk.Pixbuf)
        gtk.TreeView.__init__(self, self.liststore)

        # the text & icon column
        tvcolumn = gtk.TreeViewColumn(_("Vulnerabilities"))
        cell = gtk.CellRendererPixbuf()
        tvcolumn.pack_start(cell, expand=False)
        tvcolumn.add_attribute(cell, "pixbuf", 3)
        cell = gtk.CellRendererText()
        tvcolumn.pack_start(cell, expand=True)
        tvcolumn.add_attribute(cell, "markup", 0)
        self.append_column(tvcolumn)

        # here we will hold the instances, the key will be stored in the store
        self.listholder = set()

    def _changedSelection(self, *w):
        '''Changed which exploit is selected.'''
        (path, column) = self.get_cursor()
        vuln = self.get_instance(path)
        self.exploitlist.set_filter(vuln)

        # un-bold the rest
        selected = vuln.get_name()
        for row in self.liststore:
            if row[1] != selected:
                row[0] = row[1]

    def set_filter(self, exploit):
        '''Sets a new filter and update the list.

        :param active: which types should be shown.
        '''
        vulns = get_exploitable_vulns(exploit)
        if vulns is None:
            self.applicable = []
        else:
            self.applicable = vulns
        
        new_liststore = gtk.ListStore(str, str, str, gtk.gdk.Pixbuf)
        new_listholder = set()
        
        self._updateList(new_liststore, new_listholder)
        self.set_model(new_liststore)
        
        self.liststore = new_liststore
        self.listholder = new_listholder

    def _getBestObjName(self, obj):
        '''
        :return: The best obj name possible
        '''

        if hasattr(obj, "get_name"):
            realname = obj.get_name()
        else:
            realname = repr(obj)
        if obj in self.applicable:
            showname = "<b>%s</b>" % realname
        else:
            showname = "%s" % realname
        return showname, realname

    def _receive_kb_items(self, location_a, location_b, info_inst):
        '''
        Gets called by the KB when one of the plugins writes something to it.
        
        We've subscribed using kb.kb.add_observer(None, None, ...) so we'll
        get all changes.
        
        :return: None, the information we'll show to the user is stored in an
                 internal variable.
        '''
        if not isinstance(info_inst, Info):
            return
        
        obj_name = info_inst.get_name()
        obj_severity = info_inst.get_severity()
        
        # Note that I can't use id(instance) here since the
        # instances that come here are created from the SQLite DB
        # and have different instances, even though they hold the
        # same information.
        idinstance = info_inst.get_uniq_id()
        
        gobject.idle_add(self.add_item_to_lstore, obj_name, obj_severity,
                         idinstance)
        
    def add_item_to_lstore(self, obj_name, obj_severity, idinstance):
        '''Updates the GUI with the given information.
        '''
        newicon = helpers.KB_ICONS.get(("vuln", obj_severity))
        if newicon is not None:
            newicon = newicon.get_pixbuf()

        self.liststore.append((obj_name, obj_severity, idinstance, newicon))


    def get_instance(self, path):
        '''Extracts the instance from the tree.

        :param path: where the user is in the tree
        :return: The instance
        '''
        info_uniq_id = self.treestore[path][2]
        info_inst = kb.kb.get_by_uniq_id(info_uniq_id)
        return info_inst
    
    def _dragDropped(self, tv, drag_context, x, y, selection_data, info, timestamp):
        '''Something was dropped (after a drag) on us.'''
        droppoint = tv.get_dest_row_at_pos(x, y)
        if droppoint is None:
            return True

        # collect info about source and dest
        (destpath, where) = droppoint
        sourcepath = self.exploitlist.get_cursor()[0]
        sourcerow = self.exploitlist.liststore[sourcepath]

        # it should select a destination row
        if where not in (gtk.TREE_VIEW_DROP_INTO_OR_AFTER, gtk.TREE_VIEW_DROP_INTO_OR_BEFORE):
            self.w3af.mainwin.sb(
                _("You must drop into a row, not in the middle of two"))
            return

        # get real objects
        exploit = self.exploitlist.get_plugin_inst(sourcepath)
        dstvuln = self.get_instance(destpath)
        if dstvuln is None:
            self.w3af.mainwin.sb(
                _("You must select a vulnerability as destination"))
            return

        self._executeExploit(exploit, dstvuln)
        return

    def _executeExploit(self, expl, vuln):
        '''Exploits a vulnerability.

        This raises a text dialog that informs how the exploit
        is going until it finishes.

        This method is going to:
            a) Create the TextDialog
            b) spawn a thread to launch the exploit process
            c) spawn a thread to read from the output manager queue

        b and c both write messages to the TextDialog.

        :param expl: the exploit to use
        :param vuln: the vulnerability to exploit
        '''
        dlg = TextDialogConsumer("Exploit!")
        
        # Start the generator that launches the exploit
        exploit_task = self._launch_exploit(dlg, expl, vuln)
        gobject.idle_add(exploit_task.next)

        return

    def _launch_exploit(self, dlg, expl, vuln):
        '''
        Launch the exploit and write messages to the TextDialog.

        :param dlg: The TextDialog.
        '''
        # get the info, and see if we can go for it
        dlg.add_message("Checking if this attack plugin can exploit this vulnerability...\n")
        vuln_id_list = vuln.get_id()

        yield True

        try:
            canexploit = expl.can_exploit(vuln_id_list)
        except w3afException, e:
            dlg.add_message(_("\nERROR: "))
            dlg.add_message(str(e) + '\n')
            dlg.done()  # set button to sensitive
            dlg.dialog_run()  # wait for user response
            yield False

        if not canexploit:
            dlg.add_message(_("Sorry, this attack plugin can not exploit this vulnerability\n"))
            dlg.done()  # set button to sensitive
            dlg.dialog_run()  # wait for user response
            yield False

        # ok, go for it!
        dlg.add_message(_("Starting exploitation process...\n"))
        yield True

        try:
            expl.exploit(vuln_id_list)
            yield True  # print the console messages to the dialog
        except w3afException, e:
            dlg.add_message(str(e) + '\n')
        else:
            dlg.add_message(_("Done\n"))
            yield True

        dlg.done()  # set button to sensitive
        dlg.dialog_run()  # wait for user response

        yield False
